// 20220117 월
// ▶클래스와 인스턴스
//-------------------------------------------------------------------------------------------------
// 생성자(Constructor)와 초기화 블럭(Initialized Block)
//-------------------------------------------------------------------------------------------------

public class Test080
{
	// 안 됨 
	/*
	int n;
	int m;

	n=100;
	m=200;
	*/
	// Q. 왜 안 될까? 
	// A. 『=』 대입 연산자
	//     연산처리는 클래스 말고 메소드에서!!
	
	// 됨
	/*
	int n = 100;
	int m = 200;
	*/
	// -> 선언과 동시에 초기화는 가능
	
	// 이렇게 해야 됨! 괄호 안에!
	int n;
	int m;
	
	// 초기화 블럭(Initialized Block)
	{
		n=20;
		m=40;
		System.out.println("초기화 블럭 실행...");
	}
	// 인스턴스 초기화 블럭(클래스 초기화 블럭은 따로 있음)
	// 변수의 초기화에 사용됨
	// 클래스 내에 블럭{} 만들고 그 안에 코드 작성하기만 하면 초기화 블럭 완성~!

	// - 생성자 : 인스턴스가 생성될 때 호출되는 '인스턴스 초기화 메소드'
    // - 생성자의 역할 : 1. 인스턴스 생성 -> 메모리 할당
    //                   2. 초기화
	//                   --------- 생성자는 초기화도 담당!!!

	// 생성자(Constructor) → 초기화 블럭이 코드를 먼저 수행했다 하더라도
	//                        최종적으로 해당 멤버들의 초기화 값을 결정하게 되는 개념~!!!
	Test080()
	{
		n=100;
		m=200;
		System.out.println("생성자 실행...");
	}

	Test080(int n, int m)
	{
		this.n = n;
		this.m = m;
		System.out.println("매개변수 있는 생성자 실행....");
	}

	// 멤버 출력 메소드 정의
	void write()
	{
		System.out.println("n:" + n + ", m:" + m);
	}

	public static void main(String[] args)
	{
		Test080 ob1 = new Test080();
		ob1.write();
		//--==> 초기화 블럭 실행...
		//      생성자 실행...
        //      n:100, m:200

		Test080 ob2 = new Test080(1234, 5678);
		ob2.write();
		//--==> 초기화 블럭 실행...
        //      매개변수 있는 생성자 실행....
        //      n:1234, m:5678
	}
}
/*
초기화 블럭이 먼저 실행되지만 문법적으로 생성자가 더욱 무거움. 
초기화 블럭 나중에 실행된 생성자가 초기화 블럭을 덮음
생성자가 더 중요!! 나중에 등장하면서 다시 정리함
*/

// 실행 결과
/*
초기화 블럭 실행...
생성자 실행...
n:100, m:200
초기화 블럭 실행...
매개변수 있는 생성자 실행....
n:1234, m:5678
계속하려면 아무 키나 누르십시오 . . .
*/